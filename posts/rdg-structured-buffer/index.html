<!DOCTYPE html>
<html
  lang="zh"
  dir="ltr"
  
>
  <head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-J7MPY59M69"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-J7MPY59M69');
</script>


<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>RDG04 StructuredBuffer的用法 | 安宁技术博客</title>

<meta name="generator" content="Hugo Eureka 0.9.1" />
<link rel="stylesheet" href="/css/eureka.min.6a378a23360d238dc3ef4df2f5cd718093f02c10c9c7eb2437c29701cd8d389ab6da5d9f21bdd3afa305fd56c1235017.css" integrity="sha384-ajeKIzYNI43D703y9c1xgJPwLBDJx&#43;skN8KXAc2NOJq22l2fIb3Tr6MF/VbBI1AX">
<script defer src="/js/eureka.min.f1639ee98d6cbd85b2b5f034d27320da962002ff83159ed4e01dbc5948c42a1ab26c2d6e74c66e93f5cec4d24dbd166d.js" integrity="sha384-8WOe6Y1svYWytfA00nMg2pYgAv&#43;DFZ7U4B28WUjEKhqybC1udMZuk/XOxNJNvRZt"></script>

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
href="https://fonts.googleapis.com/css2?family=Raleway:wght@400;600;700&family=Noto+Sans+SC:wght@400;600;700&display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/base16/dracula.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js"
   crossorigin></script>
  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/dart.min.js"
     crossorigin></script>


<script defer type="text/javascript" src="/js/fontawesome.min.21e8b39981ed3daeb0a9cc76d82dc2cc5e8c86fb1c305118c329f7a693fafaa7de4c2c3d7a8346e70ffdd2261861a32d.js" integrity="sha384-IeizmYHtPa6wqcx22C3CzF6MhvscMFEYwyn3ppP6&#43;qfeTCw9eoNG5w/90iYYYaMt"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css"
   integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" 
  integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js"
   integrity="sha384-&#43;XBljXPPiv&#43;OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>


<script defer src="https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js" 
  integrity="sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0"  crossorigin></script>


<style type="text/css">
em {
    font-weight:bolder;
    color: #cf7800;
    font-style:normal;
}
pre{
    font-family:'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif
}
</style>
<link rel="icon" type="image/png" sizes="32x32" href="/images/icon_hubdd24626628e1fb15c6cca6b0125f135_22603_32x32_fill_box_center_3.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/icon_hubdd24626628e1fb15c6cca6b0125f135_22603_180x180_fill_box_center_3.png">

<meta name="description"
  content="StructuredBuffer适合于向Shader传入大量数据，例如一个数组。 1 用于RDG_BUFFER_SRV 1.1 定义结构体 就是一个普通的C&#43;&#43;结构">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"文章",
      "item":"/posts/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"RDG04 StructuredBuffer的用法",
      "item":"/posts/rdg-structured-buffer/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "/posts/rdg-structured-buffer/"
    },
    "headline": "RDG04 StructuredBuffer的用法 | 安宁技术博客","datePublished": "2022-11-07T00:10:45+08:00",
    "dateModified": "2022-11-07T00:10:45+08:00",
    "wordCount":  2167 ,
    "publisher": {
        "@type": "Person",
        "name": "An Ning",
        "logo": {
            "@type": "ImageObject",
            "url": "/images/icon.png"
        }
        },
    "description": "StructuredBuffer适合于向Shader传入大量数据，例如一个数组。 1 用于RDG_BUFFER_SRV 1.1 定义结构体 就是一个普通的C\u002b\u002b结构"
}
</script><meta property="og:title" content="RDG04 StructuredBuffer的用法 | 安宁技术博客" />
<meta property="og:type" content="article" />


<meta property="og:image" content="/images/icon.png">


<meta property="og:url" content="/posts/rdg-structured-buffer/" />




<meta property="og:description" content="StructuredBuffer适合于向Shader传入大量数据，例如一个数组。 1 用于RDG_BUFFER_SRV 1.1 定义结构体 就是一个普通的C&#43;&#43;结构" />




<meta property="og:locale" content="zh" />




<meta property="og:site_name" content="安宁技术博客" />






<meta property="article:published_time" content="2022-11-07T00:10:45&#43;08:00" />


<meta property="article:modified_time" content="2022-11-07T00:10:45&#43;08:00" />



<meta property="article:section" content="posts" />


<meta property="article:tag" content="图形学" />

<meta property="article:tag" content="UE" />

<meta property="article:tag" content="RDG" />

<meta property="article:tag" content="StructuredBuffer" />











<meta property="og:see_also" content="/posts/rdg-graphics-pipeline-state-initializer/" />



<meta property="og:see_also" content="/posts/rdg-addpass/" />



<meta property="og:see_also" content="/posts/rdg-uniformbuffer/" />



<meta property="og:see_also" content="/posts/rdg-shader-params/" />






  </head>
  <body class="flex min-h-screen flex-col">

    <header
      class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"
    >
      <div class="mx-auto w-full max-w-screen-xl"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if (((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
    <a href="/" class="me-6 text-primary-text text-xl font-bold">安宁技术博客</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0">
            <a href="/categories/ue4" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">UE4</a>
            <a href="/categories/ue5" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">UE5</a>
            <a href="/categories/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">所有分类</a>
            <a href="/series/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">系列</a>
            <a href="/tags/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">Tags</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka" name="Light">浅色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Dark">深色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Auto">自动</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change', switchDarkMode)
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }

    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });
</script>
</div>
    </header>
    <main class="grow pt-16">
        <div class="pl-scrollbar">
          <div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8">
  
  
  <div class="grid grid-cols-2 gap-4 lg:grid-cols-8 lg:pt-12">
    <div
      class=" bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"
    >
      <article class="prose">
  <h1 class="mb-4">RDG04 StructuredBuffer的用法</h1>

  <div
  class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"
>
  <div class="me-6 my-2">
    <i class="fas fa-calendar me-1"></i>
    <span
      >2022-11-07</span
    >
  </div>
  <div class="me-6 my-2">
    <i class="fas fa-clock me-1"></i>
    <span>5分钟阅读时长</span>
  </div>

  
    <div class="me-6 my-2">
      <i class="fas fa-folder me-1"></i>
      
        <a href="/categories/ue5/" class="hover:text-eureka"
          >UE5</a
        >
      
    </div>
  

  
    <div class="me-6 my-2">
      <i class="fas fa-th-list me-1"></i>
      
        <a href="/series/rdg/" class="hover:text-eureka"
          >RDG</a
        >
      
    </div>
  
</div>


  
  

  <p>StructuredBuffer适合于向Shader传入大量数据，例如一个数组。</p>
<h2 id="1-用于rdg_buffer_srv">1 用于RDG_BUFFER_SRV</h2>
<h3 id="11-定义结构体">1.1 定义结构体</h3>
<p>就是一个普通的C++结构体（不需要是USTRUCT)</p>
<pre><code class="language-cpp">struct ShaderPrintItem
{
    FVector2D ScreenPos;
    int32 Value;
    int32 Type;
};
</code></pre>
<h3 id="12-定义shader参数">1.2 定义Shader参数</h3>
<p>使用 <em>SHADER_PARAMETER_RDG_BUFFER_SRV</em> 宏来定义一个由RDG跟踪的StructuredBuffer</p>
<pre><code class="language-cpp">class FShaderDrawSymbols : public FGlobalShader
	{
	public:
		FShaderDrawSymbols()
		{}

		FShaderDrawSymbols(const ShaderMetaType::CompiledShaderInitializerType&amp; Initializer)
			: FGlobalShader(Initializer)
		{}

		BEGIN_SHADER_PARAMETER_STRUCT(FParameters, )
			RENDER_TARGET_BINDING_SLOTS()
			SHADER_PARAMETER_STRUCT_REF(FUniformBufferParameters, UniformBufferParameters)
			SHADER_PARAMETER_TEXTURE(Texture2D, MiniFontTexture)
			SHADER_PARAMETER_RDG_BUFFER_SRV(StructuredBuffer&lt;ShaderPrintItem&gt;, SymbolsBuffer)
			RDG_BUFFER_ACCESS(IndirectDrawArgsBuffer, ERHIAccess::IndirectArgs)
		END_SHADER_PARAMETER_STRUCT()

		static bool ShouldCompilePermutation(FGlobalShaderPermutationParameters const&amp; Parameters)
		{
			return IsSupported(Parameters.Platform);
		}
	};

class FShaderDrawSymbolsVS : public FShaderDrawSymbols
{
    DECLARE_GLOBAL_SHADER(FShaderDrawSymbolsVS);
    SHADER_USE_PARAMETER_STRUCT(FShaderDrawSymbolsVS, FShaderDrawSymbols);
};

IMPLEMENT_GLOBAL_SHADER(FShaderDrawSymbolsVS, &quot;/Engine/Private/ShaderPrintDraw.usf&quot;, &quot;DrawSymbolsVS&quot;, SF_Vertex);

class FShaderDrawSymbolsPS : public FShaderDrawSymbols
{
    DECLARE_GLOBAL_SHADER(FShaderDrawSymbolsPS);
    SHADER_USE_PARAMETER_STRUCT(FShaderDrawSymbolsPS, FShaderDrawSymbols);
};

IMPLEMENT_GLOBAL_SHADER(FShaderDrawSymbolsPS, &quot;/Engine/Private/ShaderPrintDraw.usf&quot;, &quot;DrawSymbolsPS&quot;, SF_Pixel);
</code></pre>
<h3 id="13-创建structureddesc">1.3 创建StructuredDesc</h3>
<pre><code class="language-cpp">FRDGBufferDesc::CreateStructuredDesc(sizeof(ShaderPrintItem), GetMaxSymbolCount() + 1)
</code></pre>
<h4 id="frdgbufferdesc">FRDGBufferDesc</h4>
<p>FRDGBufferDesc是一个描述结构体的类型，创建<em>FRDGBufferDesc</em>一般使用静态函数 <em>CreateStructuredDesc</em>:</p>
<pre><code class="language-cpp">static FRDGBufferDesc CreateStructuredDesc(uint32 BytesPerElement, uint32 NumElements)
</code></pre>
<p>两个参数分别描述了StructuredBuffer一个元素有多少个字节，以及一共有多少个元素。注意StructuredBuffer的元素数量在这里就需要指定，并且后面是无法修改的。也就是说不可以实现动态长度的StructuredBuffer。</p>
<h3 id="14-创建buffer">1.4 创建Buffer</h3>
<pre><code class="language-cpp">FRDGBufferRef SymbolBuffer = GraphBuilder.CreateBuffer(FRDGBufferDesc::CreateStructuredDesc(sizeof(ShaderPrintItem), GetMaxSymbolCount() + 1), TEXT(&quot;ShaderPrintSymbolBuffer&quot;));
</code></pre>
<p>对于RDG跟踪的Buffer，使用 <em>FRDGBuilder.CreateBuffer</em>函数来创建,它最常用的函数重载原型如下：</p>
<pre><code class="language-cpp">inline FRDGBufferRef FRDGBuilder::CreateBuffer(
	const FRDGBufferDesc&amp; Desc,
	const TCHAR* Name,
	ERDGBufferFlags Flags)
</code></pre>
<p>它接受一个FRDGBufferDesc，一个名称，和一个ERDGBufferFlags参数。其中FRDGBufferDesc已经在1.3中讲解</p>
<h4 id="name">Name</h4>
<p>名称是一个标识，用于图形调试。</p>
<h4 id="erdgbufferflags">ERDGBufferFlags</h4>
<p>ERDGBufferFlags枚举定义如下：</p>
<pre><code class="language-cpp">/** Flags to annotate a render graph buffer. */
enum class ERDGBufferFlags : uint8
{
	None = 0,

	/** Tag the buffer to survive through frame, that is important for multi GPU alternate frame rendering. */
	MultiFrame = 1 &lt;&lt; 0,

	/** The buffer may only be used for read-only access within the graph. This flag is only allowed for registered buffers. */
	ReadOnly = 1 &lt;&lt; 1, 

	/** Force the graph to track this resource even if it can be considered as readonly (no UAV, no RTV, etc.) This allows the graph copying from and to textures, and handling the corresponding transitions, for example.
	 This flag is only allowed for registered buffers. Mutually exclusive with ReadOnly. */
	ForceTracking = 1 &lt;&lt; 2,
};
</code></pre>
<p>MultiFrame 表示让这个Buffer的生命周期是多帧的（不止一帧），ReadOnly表示这个Buffer在RDG中仅仅用于只读的用途。ForceTracking表示强制RDG追踪该资源，即使它可以被当作只读的（不是UAV, RTV等）。着就允许rdg 向纹理拷贝这个buffer，或者从纹理拷贝到这个buffer，并处理好资源转换。</p>
<h3 id="14-创建srv视图">1.4 创建SRV视图</h3>
<pre><code class="language-cpp">typedef FShaderDrawSymbols SHADER;
TShaderMapRef&lt; FShaderDrawSymbolsVS &gt; VertexShader(GlobalShaderMap);
TShaderMapRef&lt; FShaderDrawSymbolsPS &gt; PixelShader(GlobalShaderMap);

SHADER::FParameters* PassParameters = GraphBuilder.AllocParameters&lt;SHADER::FParameters&gt;();
PassParameters-&gt;RenderTargets[0] = FRenderTargetBinding(OutputTexture.Texture, ERenderTargetLoadAction::ELoad);
PassParameters-&gt;UniformBufferParameters = UniformBuffer;
PassParameters-&gt;MiniFontTexture = FontTexture;
PassParameters-&gt;SymbolsBuffer = GraphBuilder.CreateSRV(SymbolBuffer);
</code></pre>
<p>使用<em>GraphBuilder.CreateSRV</em>函数为上一步创建的StructuredBuffer创建一个SRV视图，并传递给Shader参数。</p>
<p>CreateSRV有三种重载, 分别是对应使用TextureSSRVDesc、BufferSRVDesc以及RDGBufferRef的情形：</p>
<pre><code class="language-cpp">FRDGTextureSRVRef CreateSRV(const FRDGTextureSRVDesc&amp; Desc);
FRDGBufferSRVRef CreateSRV(const FRDGBufferSRVDesc&amp; Desc);
FORCEINLINE FRDGBufferSRVRef CreateSRV(FRDGBufferRef Buffer, EPixelFormat Format);
</code></pre>
<blockquote>
<p>我们这里只给了一个FRDGBufferRef的参数，但是没有给第二个参数，且 FRDGBufferRef到FRDGBufferSRVDesc之间是可以直接进行隐式转换的，因此这里调用的是第二种重载。</p>
</blockquote>
<h3 id="15-随shader参数传入pass">1.5 随Shader参数传入Pass</h3>
<pre><code class="language-cpp">GraphBuilder.AddPass(
				RDG_EVENT_NAME(&quot;ShaderPrint::DrawSymbols&quot;),
				PassParameters,
				ERDGPassFlags::Raster,
                //.....
</code></pre>
<h3 id="16-usf中读取structuredbuffer">1.6 Usf中读取StructuredBuffer</h3>
<p>在usf文件的开头，声明一个StructuredBuffer，其泛型参数的结构体类型要和第一步C++中声明的结构体类型对应。</p>
<pre><code class="language-c">struct FPackedShaderPrintItem
{
	float2 ScreenPos; // Position in normalized coordinates
	int Value;        // Cast to value or symbol
	uint TypeAndColor;//
};

StructuredBuffer&lt;FPackedShaderPrintItem&gt; SymbolsBuffer;
</code></pre>
<p>之后就可以当作数据去获取它的值，需要注意的是下标不可以超过1.3中定义的Buffer的长度。</p>
<pre><code class="language-c">FShaderPrintItem Symbol = UnpackShaderPrintItem(SymbolsBuffer[InstanceId + SHADER_PRINT_VALUE_OFFSET]);
</code></pre>
<h2 id="2-用于rdg_buffer_uav">2 用于RDG_BUFFER_UAV</h2>
<p>和用于RDG_BUFFER_SRV大致相同，这里只说两者的区别。</p>
<h3 id="21-shader参数类型不同">2.1 Shader参数类型不同</h3>
<p>Shader的参数声明类型不同，SRV中是 StructuredBuffer&lt;&gt;，而这里是 RWStructuredBuffer&lt;&gt;，RW 意为ReadWrite，可读可写，这也是UAV的特性。</p>
<h3 id="22-创建资源视图的函数不同">2.2 创建资源视图的函数不同</h3>
<p>在SRV中我们使用的是CreateSRV函数，这里则使用CreateUAV函数，CreateUAV函数有四种重载：</p>
<pre><code class="language-cpp">FRDGTextureUAVRef CreateUAV(FRDGTextureRef Texture, ERDGUnorderedAccessViewFlags Flags = ERDGUnorderedAccessViewFlags::None);
FRDGBufferUAVRef CreateUAV(FRDGBufferRef Buffer, EPixelFormat Format, ERDGUnorderedAccessViewFlags Flags = ERDGUnorderedAccessViewFlags::None);
FORCEINLINE FRDGTextureUAVRef CreateUAV(const FRDGTextureUAVDesc&amp; Desc, ERDGUnorderedAccessViewFlags InFlags);
FORCEINLINE FRDGBufferUAVRef CreateUAV(const FRDGBufferUAVDesc&amp; Desc, ERDGUnorderedAccessViewFlags InFlags);
</code></pre>
<p>依次对应的是使用RDGTextureRef、RDGBufferRef、RDGTextureUAVDesc、RDGBufferUAVDesc的情况，且参数各有不同。</p>
<p>一个使用范例:</p>
<pre><code class="language-cpp">PassParameters-&gt;RWSymbolsBuffer = GraphBuilder.CreateUAV(SymbolBuffer, EPixelFormat::PF_R32_UINT);
</code></pre>
<h2 id="3-用于rdg_buffer">3 用于RDG_BUFFER</h2>
<h3 id="定义shader参数">定义Shader参数</h3>
<h2 id="4-从cpu向structuredbuffer赋值">4 从CPU向StructuredBuffer赋值</h2>
<p>虚幻已经为我们写好了一组工具函数<em>CreateStructuredBuffer</em>来解决这个事情，它定义于RenderGraphUtils.h， 使用时需要include该文件。</p>
<p>该函数有多个重载，分别适用于不同情形，这里仅列举出常见的几种，注意看源码的注释，其中有些函数实现了创建、</p>
<pre><code class="language-cpp">/** 第一种最为常用，适用于所有信息都使用struct存储好的情况
 *  Creates a structured buffer with initial data by creating an upload pass. */
RENDERCORE_API FRDGBufferRef CreateStructuredBuffer(
	FRDGBuilder&amp; GraphBuilder,
	const TCHAR* Name,
	uint32 BytesPerElement,
	uint32 NumElements,
	const void* InitialData,
	uint64 InitialDataSize,
	ERDGInitialDataFlags InitialDataFlags = ERDGInitialDataFlags::None);

/** 第二种不常用，适用于创建时不清楚数据数量、初始数据内容等信息的
 *  A variant where NumElements, InitialData, and InitialDataSize are supplied through callbacks. This allows creating a buffer with
 *  information unknown at creation time. Though, data must be ready before the most recent RDG pass that references the buffer
 *  is executed.
 */
RENDERCORE_API FRDGBufferRef CreateStructuredBuffer(
	FRDGBuilder&amp; GraphBuilder,
	const TCHAR* Name,
	uint32 BytesPerElement,
	FRDGBufferNumElementsCallback&amp;&amp; NumElementsCallback,
	FRDGBufferInitialDataCallback&amp;&amp; InitialDataCallback,
	FRDGBufferInitialDataSizeCallback&amp;&amp; InitialDataSizeCallback);

/** 第三种用于从TArray获取初始数组
 * Helper to create a structured buffer with initial data from a TArray.
 */
template &lt;typename ElementType, typename AllocatorType&gt;
FORCEINLINE FRDGBufferRef CreateStructuredBuffer(
	FRDGBuilder&amp; GraphBuilder,
	const TCHAR* Name,
	const TArray&lt;ElementType, AllocatorType&gt;&amp; InitialData,
	ERDGInitialDataFlags InitialDataFlags = ERDGInitialDataFlags::None)
{
	static const ElementType DummyElement = ElementType();
	if (InitialData.Num() == 0)
	{
		return CreateStructuredBuffer(GraphBuilder, Name, InitialData.GetTypeSize(), 1, &amp;DummyElement, InitialData.GetTypeSize(), ERDGInitialDataFlags::NoCopy);
	}
	return CreateStructuredBuffer(GraphBuilder, Name, InitialData.GetTypeSize(), InitialData.Num(), InitialData.GetData(), InitialData.Num() * InitialData.GetTypeSize(), InitialDataFlags);
}

</code></pre>
<p>TODO: 具体使用范例
另起一篇，分析RDG中资源的串联</p>

</article>


      
        <div class="my-4">
    
    <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#图形学</a>
    
    <a href="/tags/ue/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#UE</a>
    
    <a href="/tags/rdg/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#RDG</a>
    
    <a href="/tags/structuredbuffer/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#StructuredBuffer</a>
    
</div>
      

      



      

      
  <div
    class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"
  >
    <div>
      
    </div>
    <div class="mt-4 md:mt-0 md:text-right">
      
        <span class="text-primary-text block font-bold">下一页</span>
        <a href="/posts/rdg-graphics-pipeline-state-initializer/" class="block">RDG04 Graphics Pipeline State Initializer</a>
      
    </div>
  </div>


      



    </div>
    
      <div class="col-span-2">
        
          
<div class="bg-secondary-bg prose max-w-none rounded p-6">
  <h3>系列文章</h3>
  
    
      <a href="/posts/rdg-structured-buffer/" class="no-underline">RDG04 StructuredBuffer的用法</a>
      <br />
    
      <a href="/posts/rdg-graphics-pipeline-state-initializer/" class="no-underline">RDG04 Graphics Pipeline State Initializer</a>
      <br />
    
      <a href="/posts/rdg-addpass/" class="no-underline">RDG03 AddPass</a>
      <br />
    
      <a href="/posts/rdg-uniformbuffer/" class="no-underline">RDG02 Uniformbuffer</a>
      <br />
    
      <a href="/posts/rdg-shader-params/" class="no-underline">RDG01-Shader参数</a>
      <br />
    
  
</div>

        
        
          <div
  class="
    bg-primary-bg
   prose sticky top-16 z-10 hidden px-6 py-4 lg:block"
>
  <h3>本页内容</h3>
</div>
<div
  class="sticky-toc  hidden px-6 pb-6 lg:block"
>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#1-用于rdg_buffer_srv">1 用于RDG_BUFFER_SRV</a>
      <ul>
        <li><a href="#11-定义结构体">1.1 定义结构体</a></li>
        <li><a href="#12-定义shader参数">1.2 定义Shader参数</a></li>
        <li><a href="#13-创建structureddesc">1.3 创建StructuredDesc</a>
          <ul>
            <li><a href="#frdgbufferdesc">FRDGBufferDesc</a></li>
          </ul>
        </li>
        <li><a href="#14-创建buffer">1.4 创建Buffer</a>
          <ul>
            <li><a href="#name">Name</a></li>
            <li><a href="#erdgbufferflags">ERDGBufferFlags</a></li>
          </ul>
        </li>
        <li><a href="#14-创建srv视图">1.4 创建SRV视图</a></li>
        <li><a href="#15-随shader参数传入pass">1.5 随Shader参数传入Pass</a></li>
        <li><a href="#16-usf中读取structuredbuffer">1.6 Usf中读取StructuredBuffer</a></li>
      </ul>
    </li>
    <li><a href="#2-用于rdg_buffer_uav">2 用于RDG_BUFFER_UAV</a>
      <ul>
        <li><a href="#21-shader参数类型不同">2.1 Shader参数类型不同</a></li>
        <li><a href="#22-创建资源视图的函数不同">2.2 创建资源视图的函数不同</a></li>
      </ul>
    </li>
    <li><a href="#3-用于rdg_buffer">3 用于RDG_BUFFER</a>
      <ul>
        <li><a href="#定义shader参数">定义Shader参数</a></li>
      </ul>
    </li>
    <li><a href="#4-从cpu向structuredbuffer赋值">4 从CPU向StructuredBuffer赋值</a></li>
  </ul>
</nav>
</div>
<script>
  window.addEventListener("DOMContentLoaded", () => {
    enableStickyToc();
  });
</script>

        
      </div>
    

    
    
      <div
        class=" bg-secondary-bg prose col-span-2 rounded p-6 lg:col-span-6"
      >
        <h3>相关</h3>
        
          <a href="/posts/rdg-graphics-pipeline-state-initializer/" class="no-underline">RDG04 Graphics Pipeline State Initializer</a>
          <br />
        
          <a href="/posts/rdg-addpass/" class="no-underline">RDG03 AddPass</a>
          <br />
        
          <a href="/posts/rdg-uniformbuffer/" class="no-underline">RDG02 Uniformbuffer</a>
          <br />
        
          <a href="/posts/rdg-shader-params/" class="no-underline">RDG01-Shader参数</a>
          <br />
        
          <a href="/posts/ue4-structured-buffer/" class="no-underline">Ue4 Structured Buffer</a>
          <br />
        
          <a href="/posts/ue4-compute-shader/" class="no-underline">Ue4 Compute Shader</a>
          <br />
        
      </div>
    
  </div>

  
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        hljs.initHighlightingOnLoad();
      });
    </script>

          </div>
        </div>
      
    </main>
    <footer class="pl-scrollbar">
      <div class="mx-auto w-full max-w-screen-xl"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">&copy; 2022 <a href="https://inlet511.github.io//">An Ning</a></a>
 &middot;  Powered by the <a href="https://github.com/wangchucheng/hugo-eureka" class="hover:text-eureka">Eureka</a> theme for <a href="https://gohugo.io" class="hover:text-eureka">Hugo</a></p>
</div></div>
    </footer>
  </body>
</html>
